{"version":2,"ops":[{"type":5,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1618504843,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDQ2MDA0MDY4Mjc="},"added":["cmd-organize"],"removed":[]},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1620241127,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDgzMjkzMjg1OA==","github-url":"https://github.com/dandi/dandi-cli/issues/69#issuecomment-832932858"},"message":"I was thinking to file a fresh distilled version of this issue asking @jwodder to add `--mandatory-fields` option to organize, but then I decided against it.  We need to figure out a more \"holistic\" approach:\n- either such configuration should be a property of a dandiset to prevent users' running `organize` with different options thus again bringing dichotomy.  cons: not really pertinent to dandiset.yaml I guess, but we do not have another location ATM which would be \"propagating\" across copies of a dandiset.\n- or we analyze all assets and perform global `dandi organize -f move` in the end (see related fresh discussion https://github.com/dandi/dandi-cli/issues/614#issuecomment-832921269). cons: would not work for partial local ones.\n- or we just instruct users with INFO message that if it is an incremental/partial organize (we might not know really if it is so reliably since it might be incremental addition of a subject into otherwise empty locally dandiset) - they needing `dandi organize -f move` on the entire dandiset.\n- another wild supplemental idea: get a listing of assets on the server (if any) and use it in \"organize\" decision.  But that would require knowing which server (ok, we can default), but also could bring problems whenever some local assets potentially changed versions of those which are already on the server.\n\nSo altogether, for the robust operation, it smells like we do need some kind of \"dandiset-level\" description on how any new addition should be organized to guarantee consistency.","files":null},{"type":3,"author":{"id":"12cb25e6e3f19b53447b05d00d7d4d53c925c908"},"timestamp":1620316019,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDgzMzYyOTM2NA==","github-url":"https://github.com/dandi/dandi-cli/issues/69#issuecomment-833629364"},"message":"this is really about all the information that's needed to do organize. currently all the metadata are extracted and then used to determine file name for each object. \n\nif the person has access to all data locally, then things are ok. current system works, even with sync.\n\n\u003e get a listing of assets on the server (if any) and use it in \"organize\" decision.\n\ni think this is necessary. with partial updates, some of the metadata is online, some of it is local, and at the level of organize the CLI doesn't know if the person wants to sync with delete or simply update. without taking into account full set of assets, it would be impossible i think to know whether the named file locally is a replacement of a remote file or simply didn't take into account a potential conflict, which could overwrite a perfectly valid and different asset in the server.\n\nif the person only has partial access to data, then we need to leave the decision to the user. \n- check if asset is in the dandiset?\n- adding a new asset to the dandiset?\n- replacing an asset in the dandiset?\nbut the CLI can also leverage folder level info (e.g., what disambiguating keys were used in the uploaded folder).\n\nare we storing the nwb object id anywhere in the assetmeta, i don't think so. perhaps we should ensure that anything that we are using to construct the name is in the assetmeta at some location. i will file an issue for this.","files":null},{"type":4,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1671470434,"metadata":{"github-id":"CE_lADODBZtRc4jWGfdzwAAAAHhGU8L"},"status":2}]}