{"version":2,"ops":[{"type":1,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1618231724,"metadata":{"github-id":"MDU6SXNzdWU4NTU5NDE0Mjg=","github-url":"https://github.com/dandi/dandi-cli/issues/554","origin":"github"},"title":"Restructure parse_dandi_url() return type","message":"As `parse_dandi_url()` grows to support a greater variety of URLs that require fetching assets in different ways, I think it's past time we change the function to return object instances with methods for retrieving a URL's client, Dandiset, and assets.\n\nSpecifically, I propose the following type hierarchy:\n\n* The return type of `parse_dandi_url()` will be an instance of the abstract class `DandiURL`, whose attributes \u0026 methods are:\n    * `api_url: str` — the base URL of the API\n    * `server_type: Literal[\"girder\", \"api\"]`\n    * `dandiset_id: str`\n    * `version_id: Optional[str]`\n    * `get_client()` — Returns either a Girder or DandiAPIClient instance, as appropriate\n    * `get_dandiset(client) -\u003e dict`\n    * `get_version_id(client) -\u003e str` — Returns `version_id` if it is set or else determines it based on the Dandiset's state\n    * `abstractmethod get_assets(client, include_metadata=False) -\u003e Iterator[dict]`\n        * Note that some subclasses may always include metadata regardless of the value of `include_metadata`.\n\n* The concrete subclasses of `DandiURL` include:\n    * `DandisetURL` — for URLs that only refer to a Dandiset (possibly with a version); `get_assets()` returns all assets in the Dandiset\n    * `AssetIDURL` — for URLs that identify an asset by ID\n    * `AssetPathPrefixURL` — for URLs that identify a collection of assets by path prefix\n    * `AssetItemURL` — for URLs that identify a specific asset by path\n    * `AssetFolderURL` — for URLs that identify a collection of assets by folder path\n\n@yarikoptic Thoughts?","files":null}]}