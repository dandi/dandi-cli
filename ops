{"version":2,"ops":[{"type":3,"author":{"id":"12cb25e6e3f19b53447b05d00d7d4d53c925c908"},"timestamp":1675120508,"metadata":{"github-id":"IC_kwDODBZtRc5UA0_D","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1409503171"},"message":"that is correct. (the iterate part could use the glob API to only get nwb assets).\n\ni was hoping to do this on the server side so we could run through in admin mode and be very careful that we are dealing with draft versions only. so a dry run option would probably be good to have.","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1675186764,"metadata":{"github-id":"IC_kwDODBZtRc5UFx13","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1410801015"},"message":"here is a code snippet for how to access with pynwb remote asset on the archive https://pynwb.readthedocs.io/en/stable/tutorials/advanced_io/streaming.html#streaming-method-2-fsspec via fsspec. @jwodder - could you please look into feasibility of enhancing Remote assets class for nwb files with ability to extract metadata from them?","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1675265903,"metadata":{"github-id":"IC_kwDODBZtRc5ULXuJ","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1412266889"},"message":"@yarikoptic As far as I can tell, the biggest problem would be the fact that our metadata-computation routines require the input to be a local file in several places (in order to set `blobDateModified`, `contentSize`, and the digest).","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1675274519,"metadata":{"github-id":"IC_kwDODBZtRc5UMO4P","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1412492815"},"message":"interesting... so indeed in this case it is not just getting it from nwb via fsspect but we would need to reuse that metadata from the asset's metadata record.","files":null},{"type":3,"author":{"id":"12cb25e6e3f19b53447b05d00d7d4d53c925c908"},"timestamp":1675289769,"metadata":{"github-id":"IC_kwDODBZtRc5UNdIy","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1412813362"},"message":"if the checksum is the same, does a PUT request on the api server allow changing blobdatemodified/contentsize? cc:ing @AlmightyYakob .\n\nfrom a function perspective one could write a shim that leverages those fields from the dandi asset metadata.","files":null},{"type":3,"author":{"id":"a9e2633aeb6d7e2366a97d09712312c2442c6054"},"timestamp":1675292574,"metadata":{"github-id":"IC_kwDODBZtRc5UNpB1","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1412862069"},"message":"\u003e if the checksum is the same, does a PUT request on the api server allow changing blobdatemodified/contentsize? cc:ing @AlmightyYakob .\n\u003e \n\u003e from a function perspective one could write a shim that leverages those fields from the dandi asset metadata.\n\nRegarding `dateModified`, if you're talking about the field within an asset's metadata, then you could make a simple PUT request, with the body containing exactly what was returned from a GET, with the `dateModified` field updated. If you're talking about the `modified` field on the asset model itself, that same approach would also work. However, you must update something, otherwise the asset won't change (i.e. if a PUT request on an asset is made with exactly the same data as exists already, nothing will be done). One thing to note is that in any case, the `asset_id` will change, since we never _update_ assets, we just create new ones.\n\nFor `contentSize`, it's different, since that's derived from the blob/zarr itself. So if you wanted to update that, you'd actually need to upload a new file with content of that size, and update the asset to point to that new asset blob.\n\nDoes that answer your question?","files":null},{"type":3,"author":{"id":"12cb25e6e3f19b53447b05d00d7d4d53c925c908"},"timestamp":1675293544,"metadata":{"github-id":"IC_kwDODBZtRc5UNwqJ","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1412893321"},"message":"@AlmightyYakob - in the server code there are some metadata fields that are not allowed to be modified by certain specific requests. so if i don't change the digest, i'm simply asking how many of the fields related to the digest are not allowed to be modified by a PUT request. an example here: https://github.com/dandi/dandi-archive/blob/master/dandiapi/api/models/asset.py#L298 . we should take the rest of this discussion offline, so this one can focus on the task at hand (which your suggestion should be fine to do).","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1675432433,"metadata":{"github-id":"IC_kwDODBZtRc5UZOhu","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1415899246"},"message":"@jwodder - could you please work out a code snippet, it doesn't need to be formalized within RemoteAsset and could be nwb specific for now, so it just gets metadata for the asset, re-extracts metadata from its URL on s3 using fsspec, submits updated metadata (mints a new asset).","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1675434772,"metadata":{"github-id":"IC_kwDODBZtRc5UZbTM","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1415951564"},"message":"@yarikoptic I don't think this can be done in just a \"snippet.\"  Too much of the current code assumes we have a local file path, and we'd have to either rewrite a bunch of stuff or just duplicate a bunch of code with a few changes.","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1675697397,"metadata":{"github-id":"IC_kwDODBZtRc5UmF2A","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1419271552"},"message":"Indeed lots of code intertwined to rely on having a file system.  Looking at the code some notes, without yet deciding on which way to proceed:\n- We already have https://github.com/dandi/dandi-cli/blob/HEAD/tools/update-assets-on-server circa July 2021\n  - that is when we still had a local backup of all assets, so it relies on having access to a blob file to 1. get digest, 2. call `nwb2asset`.\n  - so we had already an 'ad-hoc' script which can no longer be used. Proves the point that we need a somewhat thought through solution\n- `nwb2asset` (calling into `get_metadata` which switches logic for different file types/bids or not) and is at large would need to: \n   - https://github.com/dandi/dandi-cli/blob/HEAD/dandi/metadata.py#L124 : we are making attempts to import 2 possible known extensions (`ndx_dandi_icephys` and `allensdk.brain_observatory.ecephys.nwb`) if [_get_pynwb_metadata](https://github.com/dandi/dandi-cli/blob/67f015ccffc944b2627c6b9c6a47860c8aa164be/dandi/pynwb_utils.py#L190) fails to open file/load metadata. It might no longer be needed since eaaa19e9 we use `load_namespaces=True` and I believe this should be sufficient to just load the metadata\n   - we can adjust `_get_pynwb_metadata` to handle `path` which if URL - uses fsspec \n   - similarly adjust `get_neurodata_types` \n   - either update `get_nwb_version` or not use/update (just take known) `nwb_version` field\n   - overall feels that some abstraction on top of `NWBHDF5IO` and `h5py.File` to open them via fsspec if URL would help here\n       - but it all might interfere with the use of `.memoize_path ` of our fscacher which relies on the argument to be a file. I don't remember what it does (just passes though?) if can't stat file on the drive (as it would be in case of URL)\n- [add_common_metadata](https://github.com/dandi/dandi-cli/blob/HEAD/dandi/metadata.py#L969) needs access to file for `blobDateModified`, `contentSize`, and `encodingFormat`. Here we might need some ad-hoc handling indeed to either copy those from an existing metadata record or have some abstraction level which would switch between local/remote files.\n- overall it does feel like we could provide some minimal abstraction of `File` -\u003e `LocalFile` (not that we do not have those already `LocalFileAsset -\u003e NWBAsset`), `RemoteFile` and have some\n  -  `.open` context manager to abstract opening file via fsspec or just passing filepath down\n  - basic interfaces in use to get size, date modified\n  - make all those functions use this abstraction instead of plain `str` for path.","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676303239,"metadata":{"github-id":"IC_kwDODBZtRc5VIC8V","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1428172565"},"message":"I believe the fsspec file classes implement all or most of Python's standard IO methods, so we might be able to adjust the relevant functions that currently take file paths to instead just take open file objects.  The only obvious problem with this would be getting the file size and mtime.","files":null},{"type":6,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676303387,"metadata":{"github-id":"UCE_lALODBZtRc5VIC8Vzi00A9c"},"target":"b24ae83b65faaa4ac21a953e6661e3f3c1ec7d9d5f50da30d097330034653474","message":"I believe the fsspec file classes implement all or most of Python's standard IO methods, so we might be able to adjust the relevant functions that currently take file paths to instead just take open file objects.  This still wouldn't address getting the file size, mtime, and MIME type, though.","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1676306830,"metadata":{"github-id":"IC_kwDODBZtRc5VIbrO","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1428273870"},"message":"that is why I wondered if it better by our custom adapter classe(s) which would use fsspec classes for IO methods and appropriate ones for size, mtime.","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676401529,"metadata":{"github-id":"IC_kwDODBZtRc5VP8Ka","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1430241946"},"message":"@yarikoptic What exactly is the next step here?  Is it to devise a `File`/`LocalFile`/`RemoteFile` hierarchy?","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1676402561,"metadata":{"github-id":"IC_kwDODBZtRc5VQBGg","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1430262176"},"message":"I think so -- devise the hierarchy and use it through out the code used to extract metadata.","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676403529,"metadata":{"github-id":"IC_kwDODBZtRc5VQFcr","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1430279979"},"message":"@yarikoptic Possible API:\n\n```\nclass File(ABC):\n    @abstractmethod\n    def open(self) -\u003e AbstractContextManager[IO[bytes]]:\n        ...\n\n    @abstractmethod\n    def get_size(self) -\u003e int:\n        ...\n\n    @abstractmethod\n    def get_mtime(self) -\u003e datetime:\n        ...\n\n    @abstractmethod\n    def get_filename(self) -\u003e str:\n        # Returns just the base filename; needed for determining MIME type based on file extensions\n        ...\n\n\nclass LocalFile(File):\n    filepath: Path\n\n    def __init__(self, path: str | Path) -\u003e None:\n        ...\n\n    # Methods use the obvious local implementations\n\n\nclass RemoteFile(File):\n    url: str\n    # Possibly add an additional optional parameter for the filename for when it can't be parsed from the URL\n\n    def __init__(self, url: str) -\u003e None:\n        ...\n\n    # Methods use fsspec\n```\n\nIn addition, we give `BaseRemoteBlobAsset` an `as_file() -\u003e RemoteFile` method (possibly with keyword parameters that are forwarded to `get_content_url()`), and we give `LocalFileAsset` an `as_file() -\u003e LocalFile` method.\n\n* We do *not* add an `as_file()` method to `BaseRemoteAsset` or `LocalAsset`, as Zarrs cannot be represented as files or URLs.\n* Question: Should the `File` hierarchy and the `as_file()` methods be publicly exposed, or should they only be used internally by dandi-cli for metadata extraction purposes?\n* Do we even want the implementation of `RemoteFile` to exist in dandi-cli (as opposed to a separate script), as adding fsspec to the project's dependencies would just drag in more stuff that's rarely used?\n    * Perhaps we could make the fsspec dependency an extra?","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1676404902,"metadata":{"github-id":"IC_kwDODBZtRc5VQLXl","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1430304229"},"message":"Sounds good. Some notes:\n- I think we better make/use `RemoteFile` more DANDI specific, as `RemoteDANDIAsset.__init__(self, url:str)` to obtain `size` and `mtime` from metadata since `mtime` from URL would correspond to time that blob was uploaded to AWS, which would differ, where `url` is the URL to the file in some instance of the DANDI archive, as the one we parse `parse_dandi_url`, or otherwise we would need to provide `instance_name`, (`dandiset`, `path`) or `asset_id`.\n- Re Question: ATM I see them only for internal extraction BUT I think it would be a great addition for public API, at large removing the need for some boiler plate code in https://pynwb.readthedocs.io/en/stable/tutorials/advanced_io/streaming.html#getting-the-location-of-the-file-on-dandi I believe.  So if you do not see a problem with it -- would be nice to expose IMHO.\n- Indeed I would not make `fsspec` a requirement -- I would indeed just make `fsspec` an extra dependency (in `extras` which has `duecredit` ATM) and delay import until that singular code location where we use it.","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676405101,"metadata":{"github-id":"IC_kwDODBZtRc5VQMSD","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1430307971"},"message":"@yarikoptic To be clear: In your first point, you're saying that `RemoteFile` should instead be called `RemoteDANDIAsset` (seems too easy to confuse with other `*Asset` classes) and that its constructor should fetch the size \u0026 mtime from the asset metadata?","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1676504340,"metadata":{"github-id":"IC_kwDODBZtRc5VXiBs","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1432232044"},"message":"yes.  I do appreciate possible confusion point, thought even to see if we could simply extend API of our existing hierarchy if we could just mix-in this functionality.","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676560161,"metadata":{"github-id":"IC_kwDODBZtRc5VbXdA","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1433237312"},"message":"@yarikoptic I'd rather have these as separate classes rather than \"polluting\" the `BaseRemoteBlobAsset` and `LocalFileAsset` namespaces with the relevant methods (In particular, `LocalFileAsset` already has `size` and `modified` properties, so if we went the \"extra methods on extant classes\" route, we'd want to give `BaseRemoteBlobAsset` properties of the same name as well, but those can easily fail due to HTTP errors or the metadata simply not having the relevant fields (not sure how possible that one is), so they semantically make more sense as methods than properties.)\n\nAs for a less confusing name for `RemoteDANDIAsset`, how about `RemoteAssetFile`?","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1676562054,"metadata":{"github-id":"IC_kwDODBZtRc5VbkKJ","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1433289353"},"message":"Sounds good","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676564048,"metadata":{"github-id":"IC_kwDODBZtRc5Vbwrs","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1433340652"},"message":"@yarikoptic I presume that remote files should be opened using the code shown [here](https://pynwb.readthedocs.io/en/stable/tutorials/advanced_io/streaming.html#streaming-method-2-fsspec).\n\n* Should the fsspec file system object be a caching file system or just a plain HTTP file system?  If caching, where should the cache be?\n* How should creation of the file system object be managed?  Should there be one global lazily-constructed file system used by all assets, or should each asset get its own instance, or something in between?\n* Is there any preference about which content URL to use for reading assets?\n* If the size and mtime cannot be retrieved from the asset metadata (because the `contentSize`/`blobDateModified` field was absent/malformed — not sure how possible that is), should the `get_size()` and `get_mtime()` methods fall back to using the `Content-Length` and `Date-Modified` HTTP headers of the URL (and, if so, what if those are absent/malformed) or something else?","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1676566978,"metadata":{"github-id":"IC_kwDODBZtRc5VcCrw","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1433414384"},"message":"- I would not bother with caching for now - it might also get used by `dandi-archive` so caching might be trickier etc. If we see the need later, we can add it (later).\n- without caching, we do not need to explicitly bother creating a filesystem instance. Can just use `with fsspec.open(url, 'r') as f:` context manager .\n- the one directly on S3\n- hm, please log warning for now if size is missing, and indeed fetch from S3 key -- should be the same ;)  as if `blobDateModified` is missing - let it be missing, it seems to be optional according to https://github.com/dandi/dandi-schema/blob/71a8ea3f8231cc8bf4fadcc51ea76db86171925f/dandischema/models.py#L1081","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676567311,"metadata":{"github-id":"IC_kwDODBZtRc5VcEpo","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1433422440"},"message":"@yarikoptic So, if `blobDateModified` is missing, what should be returned by `get_mtime()` when `add_common_metadata()` needs a \"modified\" time?","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1676576316,"metadata":{"github-id":"IC_kwDODBZtRc5Vczla","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1433614682"},"message":"what about:\n- `get_mtime()` returns `None` whenever it doesn't know\n- `add_common_metadata()` doesn't assign `blobDateModified` at all if returned `mtime` is None","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676579117,"metadata":{"github-id":"IC_kwDODBZtRc5VdBWQ","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1433671056"},"message":"@yarikoptic What should we do about `get_neurodata_types()` and `nwb_has_external_links()`, which use fscacher, which assumes that the first argument is something that can be passed to `os.realpath()`?","files":null},{"type":6,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676579554,"metadata":{"github-id":"UCE_lALODBZtRc5VdBWQzi1n9Fc"},"target":"c482855a4af4a15068ff6910f6318809803b1ff03c12e515273d6903f0ba94b7","message":"@yarikoptic What should we do about `get_metadata()`, `get_neurodata_types()`, and `nwb_has_external_links()`, which use fscacher, which assumes that the first argument is something that can be passed to `os.realpath()`?","files":null},{"type":6,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676579751,"metadata":{"github-id":"UCE_lALODBZtRc5VdBWQzi1oAHo"},"target":"c482855a4af4a15068ff6910f6318809803b1ff03c12e515273d6903f0ba94b7","message":"@yarikoptic What should we do about `get_metadata()`, `get_neurodata_types()`, and `nwb_has_external_links()`, which use fscacher, which assumes that the first argument is something that can be passed to `os.realpath()`?\n\nAlso, do we want `get_metadata()` to still support being called with a directory path?  That doesn't seem to be used anywhere.","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1676585670,"metadata":{"github-id":"IC_kwDODBZtRc5Vdd3I","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1433787848"},"message":"\u003e @yarikoptic What should we do about `get_metadata()`, `get_neurodata_types()`, and `nwb_has_external_links()`, which use fscacher, which assumes that the first argument is something that can be passed to `os.realpath()`?\n\nideally we create some local adapter to trigger fscacher wrapped function if it is a local path instance and proceed without fscacher otherwise.  But I do not see ATM an easy solution there ... I am afraid we need to improve `fscacher` to be able to handle some non-str objects which have some magical methods (e.g. `.as_path`) or smth as non-pretty like that. hm. May be you have better ideas?\n\nMeanwhile - just disable those decorators I guess :-/ \n\nre `get_metadata` \n- can't it obtain path to .zarr ? \n- I thought it should have also worked if we pointed it to dandiset, to load from `dandiset.yaml` but it seems just to not work at all:\n```\n❯ dandi -l error ls ../dandisets/000003/dandiset.yaml\n- errors: 1\n  path: ../dandisets/000003/dandiset.yaml\n  size: 3614\n\n❯ dandi -l error ls ../dandisets/000003/\n- path: ../dandisets/000003/\n```\n\nso -- my concern is primarily .zarr directory.","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676643202,"metadata":{"github-id":"IC_kwDODBZtRc5Vg-Q4","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1434707000"},"message":"@yarikoptic\n\n* My idea is to update fscacher to wrap the `os.realpath()` call in `try`, and if a `TypeError` is raised, we bypass the cache.\n* `get_metadata()` doesn't do anything with Zarrs.","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1676646042,"metadata":{"github-id":"IC_kwDODBZtRc5VhNDD","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1434767555"},"message":"\u003e @yarikoptic\n\u003e \n\u003e * My idea is to update fscacher to wrap the `os.realpath()` call in `try`, and if a `TypeError` is raised, we bypass the cache.\n\nBut that alone wouldn't be sufficient to work with File object, in effect making fscaching defunct on local files too, or am I missing something?","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1676646103,"metadata":{"github-id":"IC_kwDODBZtRc5VhNbV","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1434769109"},"message":"May be if it `str` that argument first, and we ensure that remote construct has str which is very unlikely to correspond to local path?","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676646340,"metadata":{"github-id":"IC_kwDODBZtRc5VhO3e","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1434775006"},"message":"@yarikoptic Alternatively, we give `LocalFile` [an `__fspath__` method](https://docs.python.org/3/library/os.html#os.PathLike) so that it can be passed to `os.realpath()`.","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1676652847,"metadata":{"github-id":"IC_kwDODBZtRc5VhwbO","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1434912462"},"message":"Oh cool! Can even subclass os.PathLike[¶](https://docs.python.org/3/library/os.html#os.PathLike) so can be explicitly isinstance checked","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676653081,"metadata":{"github-id":"IC_kwDODBZtRc5VhyA7","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1434918971"},"message":"@yarikoptic I believe the builtin functions that work with paths accept anything that implements `__fspath__` without requiring them to actually subclass `PathLike`; see [\"path-like object\" in the glossary](https://docs.python.org/3/glossary.html#term-path-like-object) and [the docs for `os.fspath()`](https://docs.python.org/3/library/os.html#os.fspath), which make no mention of `PathLike`.  Hence, instead of using `isinstance`, fscacher should just check for a `TypeError`.","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1676683874,"metadata":{"github-id":"IC_kwDODBZtRc5VjxuJ","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1435442057"},"message":"cool, indeed talks about \"protocol\" there and not inheritance. So overall -- sounds great.","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1676909311,"metadata":{"github-id":"IC_kwDODBZtRc5Vqrl2","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1437251958"},"message":"@yarikoptic Due to some changes I made while implementing this, I'm currently getting type-checking errors involving [`_sanitize_nwb_version()`](https://github.com/dandi/dandi-cli/blob/7e579fb74ecd8012bd0aac00d7236aae46871670/dandi/pynwb_utils.py#L51).  This function currently accepts `str`s and `int`s, stringifying the latter, but any other type is returned as-is (with a warning logged).  This messes up type-checking, as there does not seem to be a guarantee that the input (coming from `h5file.attrs[\"nwb_version\"]`) is in fact a string.  Would it be acceptable to stringify inputs of non-str, non-int types?  And similarly change the lambda in [this line](https://github.com/dandi/dandi-cli/blob/7e579fb74ecd8012bd0aac00d7236aae46871670/dandi/pynwb_utils.py#L101) to stringify `v`?","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1676928275,"metadata":{"github-id":"IC_kwDODBZtRc5Vr3wQ","github-url":"https://github.com/dandi/dandi-cli/issues/1196#issuecomment-1437563920"},"message":"sorry for the delay. https://github.com/NeurodataWithoutBorders/nwb-schema/blob/HEAD/core/nwb.file.yaml#L9 says it should be `text`. So, assuming that we are getting away from the wild west of prior versions where it was specified more *loosely*, yeah - let's just stringify there.  I don't think we use `get_nwb_version` with `sanitize=True` anywhere, so we might as well deprecate that option while at it.","files":null},{"type":4,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1677605135,"metadata":{"github-id":"CE_lADODBZtRc5dLopzzwAAAAICXEru"},"status":2}]}