{"version":2,"ops":[{"type":5,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1633536946,"metadata":{"github-id":"LE_lADODBZtRc48t8OXzwAAAAFDKNMv"},"added":["enhancement"],"removed":[]},{"type":5,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1633536946,"metadata":{"github-id":"LE_lADODBZtRc48t8OXzwAAAAFDKNM1"},"added":["UX"],"removed":[]},{"type":5,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1633536946,"metadata":{"github-id":"LE_lADODBZtRc48t8OXzwAAAAFDKNM6"},"added":["DX"],"removed":[]},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1633557565,"metadata":{"github-id":"IC_kwDODBZtRc433ONi","github-url":"https://github.com/dandi/dandi-cli/issues/791#issuecomment-937223010"},"message":"@yarikoptic \n\n\u003e avoid duplication of params specification in decorators AND function signature\n\nTo an extent.  If you want to give an option both a long and a short form (like `-e`/`--existing`), typer requires you to write out the name of the option twice: `def func(existing: bool = typer.Option(False, \"-e\", \"--existing\"))`.\n\n\u003e provide both Python and CLI interfaces to the same functionality!\n\nOnly for the most trivial commands.  If you want an option to have something as simple as help text, you lose the ability to have a default argument when called like a function (regardless of whether you apply an `app = typer.Typer()` decorator or not).  For example, given the following module:\n\n```python\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef func(foo: str = typer.Option(\"bar\", help=\"What to foo\")) -\u003e None:\n    print(f\"{foo=}\")\n\nif __name__ == \"__main__\":\n    typer.run(func)\n```\n\n`foo` will be `\"bar\"` when the script is run as a command without any arguments, but if you call `func()` directly, you get:\n\n```\nfoo=\u003ctyper.models.OptionInfo object at 0x103414d60\u003e\n```\n\nThere's also the fact that typer doesn't support defining options as reusable decorators.  In a related vein, you can't use environment variables like `DANDI_DEVEL` to control whether an option exists.  The best ways I can think of to reimplement `DANDI_DEVEL` with typer are to either do something like this:\n\n```python\nif os.environ.get(\"DANDI_DEVEL\"):\n    def download(\n        ### all the public options go here\n        dandi_instance: str = typer.Option(\"dandi\", \"--dandi-instance, \"-i\"),\n        ### any other devel options go here\n    ):\n        _download(**public_options, **devel_options)\nelse:\n    def download(\n        ### all the public options again\n    ):\n        _download(**public_options, dandi_instance=\"dandi\", ...)\n```\n\nor just set the options' `hidden` configuration to `bool(os.environ.get(\"DANDI_DEVEL\"))` so that they are usable regardless of the value of `DANDI_DEVEL` but only show up in `--help` output when the envvar is set.","files":null},{"type":6,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1633557676,"metadata":{"github-id":"UCE_lALODBZtRc433ONizh4hagg"},"target":"f865acbb0f32bbc2d67b929efa58a5b6b7f7e99c9222de4e28ed19a7abd52449","message":"@yarikoptic \n\n\u003e avoid duplication of params specification in decorators AND function signature\n\nTo an extent.  If you want to give an option both a long and a short form (like `-e`/`--existing`), typer requires you to write out the name of the option twice: `def func(existing: bool = typer.Option(False, \"-e\", \"--existing\"))`.\n\n\u003e provide both Python and CLI interfaces to the same functionality!\n\nOnly for the most trivial commands.  If you want an option to have something as simple as help text, you lose the ability to have a default argument when called like a function (regardless of whether you apply an `app = typer.Typer()` decorator or not).  For example, given the following module:\n\n```python\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef func(foo: str = typer.Option(\"bar\", help=\"What to foo\")) -\u003e None:\n    print(f\"{foo=}\")\n\nif __name__ == \"__main__\":\n    typer.run(func)\n```\n\n`foo` will be `\"bar\"` when the script is run as a command without any arguments, but if you call `func()` directly, you get:\n\n```\nfoo=\u003ctyper.models.OptionInfo object at 0x103414d60\u003e\n```\n\nThere's also the fact that typer doesn't support defining options as reusable decorators.  In a related vein, you can't use environment variables like `DANDI_DEVEL` to control whether an option exists.  The best ways I can think of to reimplement `DANDI_DEVEL` with typer are to either do something like this:\n\n```python\nif os.environ.get(\"DANDI_DEVEL\"):\n    @app\n    def download(\n        ### all the public options go here\n        dandi_instance: str = typer.Option(\"dandi\", \"--dandi-instance, \"-i\"),\n        ### any other devel options go here\n    ):\n        _download(**public_options, **devel_options)\nelse:\n    @app\n    def download(\n        ### all the public options again\n    ):\n        _download(**public_options, dandi_instance=\"dandi\", ...)\n```\n\nor just set the options' `hidden` configuration to `bool(os.environ.get(\"DANDI_DEVEL\"))` so that they are usable regardless of the value of `DANDI_DEVEL` but only show up in `--help` output when the envvar is set.","files":null},{"type":6,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1633557867,"metadata":{"github-id":"UCE_lALODBZtRc433ONizh4hbgI"},"target":"f865acbb0f32bbc2d67b929efa58a5b6b7f7e99c9222de4e28ed19a7abd52449","message":"@yarikoptic \n\n\u003e avoid duplication of params specification in decorators AND function signature\n\nTo an extent.  If you want to give an option both a long and a short form (like `-e`/`--existing`), typer requires you to write out the name of the option twice: `def func(existing: bool = typer.Option(False, \"-e\", \"--existing\"))`.\n\n\u003e provide both Python and CLI interfaces to the same functionality!\n\nOnly for the most trivial commands.  If you want an option to have something as simple as help text, you lose the ability to have a default argument when called like a function (regardless of whether you apply an `app = typer.Typer()` decorator or not).  For example, given the following module:\n\n```python\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef func(foo: str = typer.Option(\"bar\", help=\"What to foo\")) -\u003e None:\n    print(f\"{foo=}\")\n\nif __name__ == \"__main__\":\n    typer.run(func)\n```\n\n`foo` will be `\"bar\"` when the script is run as a command without any arguments, but if you call `func()` directly, you get:\n\n```\nfoo=\u003ctyper.models.OptionInfo object at 0x103414d60\u003e\n```\n\nThere's also the fact that typer doesn't support defining options as reusable decorators.  In a related vein, you can't use environment variables like `DANDI_DEVEL` to control whether an option exists.  The best ways I can think of to reimplement `DANDI_DEVEL` with typer are to either do something like this:\n\n```python\nif os.environ.get(\"DANDI_DEVEL\"):\n    @app.command()\n    def download(\n        ### all the public options go here\n        dandi_instance: str = typer.Option(\"dandi\", \"--dandi-instance, \"-i\"),\n        ### any other devel options go here\n    ):\n        _download(**public_options, **devel_options)\nelse:\n    @app.command()\n    def download(\n        ### all the public options again\n    ):\n        _download(**public_options, dandi_instance=\"dandi\", ...)\n```\n\nor just set the options' `hidden` configuration to `bool(os.environ.get(\"DANDI_DEVEL\"))` so that they are usable regardless of the value of `DANDI_DEVEL` but only show up in `--help` output when the envvar is set.","files":null},{"type":6,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1633558223,"metadata":{"github-id":"UCE_lALODBZtRc433ONizh4hdN0"},"target":"f865acbb0f32bbc2d67b929efa58a5b6b7f7e99c9222de4e28ed19a7abd52449","message":"@yarikoptic \n\n\u003e avoid duplication of params specification in decorators AND function signature\n\nTo an extent.  If you want to give an option both a long and a short form (like `-e`/`--existing`), typer requires you to write out the name of the option twice: `def func(existing: bool = typer.Option(False, \"-e\", \"--existing\"))`.\n\n\u003e provide both Python and CLI interfaces to the same functionality!\n\nOnly for the most trivial commands.  If you want an option to have something as simple as help text, you lose the ability to have a default argument when called like a function (regardless of whether you apply an `app = typer.Typer()` decorator or not).  For example, given the following module:\n\n```python\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef func(foo: str = typer.Option(\"bar\", help=\"What to foo\")) -\u003e None:\n    print(f\"{foo=}\")\n\nif __name__ == \"__main__\":\n    typer.run(func)\n```\n\n`foo` will be `\"bar\"` when the script is run as a command without any arguments, but if you call `func()` directly, you get:\n\n```\nfoo=\u003ctyper.models.OptionInfo object at 0x103414d60\u003e\n```\n\nThere's also the fact that typer doesn't support defining options as reusable decorators (EDIT: Well, you can do something like `REUSABLE_OPTION = typer.Option(\"default\", \"--resusable\", help=\"...\") at the global level and then put `reusable_option: str = REUSABLE_OPTION` in all your command signatures.)  In a related vein, you can't use environment variables like `DANDI_DEVEL` to control whether an option exists.  The best ways I can think of to reimplement `DANDI_DEVEL` with typer are to either do something like this:\n\n```python\nif os.environ.get(\"DANDI_DEVEL\"):\n    @app.command()\n    def download(\n        ### all the public options go here\n        dandi_instance: str = typer.Option(\"dandi\", \"--dandi-instance, \"-i\"),\n        ### any other devel options go here\n    ):\n        _download(**public_options, **devel_options)\nelse:\n    @app.command()\n    def download(\n        ### all the public options again\n    ):\n        _download(**public_options, dandi_instance=\"dandi\", ...)\n```\n\nor just set the options' `hidden` configuration to `bool(os.environ.get(\"DANDI_DEVEL\"))` so that they are usable regardless of the value of `DANDI_DEVEL` but only show up in `--help` output when the envvar is set.","files":null},{"type":6,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1633558236,"metadata":{"github-id":"UCE_lALODBZtRc433ONizh4hdQs"},"target":"f865acbb0f32bbc2d67b929efa58a5b6b7f7e99c9222de4e28ed19a7abd52449","message":"@yarikoptic \n\n\u003e avoid duplication of params specification in decorators AND function signature\n\nTo an extent.  If you want to give an option both a long and a short form (like `-e`/`--existing`), typer requires you to write out the name of the option twice: `def func(existing: bool = typer.Option(False, \"-e\", \"--existing\"))`.\n\n\u003e provide both Python and CLI interfaces to the same functionality!\n\nOnly for the most trivial commands.  If you want an option to have something as simple as help text, you lose the ability to have a default argument when called like a function (regardless of whether you apply an `app = typer.Typer()` decorator or not).  For example, given the following module:\n\n```python\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef func(foo: str = typer.Option(\"bar\", help=\"What to foo\")) -\u003e None:\n    print(f\"{foo=}\")\n\nif __name__ == \"__main__\":\n    typer.run(func)\n```\n\n`foo` will be `\"bar\"` when the script is run as a command without any arguments, but if you call `func()` directly, you get:\n\n```\nfoo=\u003ctyper.models.OptionInfo object at 0x103414d60\u003e\n```\n\nThere's also the fact that typer doesn't support defining options as reusable decorators (EDIT: Well, you can do something like `REUSABLE_OPTION = typer.Option(\"default\", \"--resusable\", help=\"...\")` at the global level and then put `reusable_option: str = REUSABLE_OPTION` in all your command signatures.)  In a related vein, you can't use environment variables like `DANDI_DEVEL` to control whether an option exists.  The best ways I can think of to reimplement `DANDI_DEVEL` with typer are to either do something like this:\n\n```python\nif os.environ.get(\"DANDI_DEVEL\"):\n    @app.command()\n    def download(\n        ### all the public options go here\n        dandi_instance: str = typer.Option(\"dandi\", \"--dandi-instance, \"-i\"),\n        ### any other devel options go here\n    ):\n        _download(**public_options, **devel_options)\nelse:\n    @app.command()\n    def download(\n        ### all the public options again\n    ):\n        _download(**public_options, dandi_instance=\"dandi\", ...)\n```\n\nor just set the options' `hidden` configuration to `bool(os.environ.get(\"DANDI_DEVEL\"))` so that they are usable regardless of the value of `DANDI_DEVEL` but only show up in `--help` output when the envvar is set.","files":null},{"type":6,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1633558250,"metadata":{"github-id":"UCE_lALODBZtRc433ONizh4hdV8"},"target":"f865acbb0f32bbc2d67b929efa58a5b6b7f7e99c9222de4e28ed19a7abd52449","message":"@yarikoptic \n\n\u003e avoid duplication of params specification in decorators AND function signature\n\nTo an extent.  If you want to give an option both a long and a short form (like `-e`/`--existing`), typer requires you to write out the name of the option twice: `def func(existing: bool = typer.Option(False, \"-e\", \"--existing\"))`.\n\n\u003e provide both Python and CLI interfaces to the same functionality!\n\nOnly for the most trivial commands.  If you want an option to have something as simple as help text, you lose the ability to have a default argument when called like a function (regardless of whether you apply an `app = typer.Typer()` decorator or not).  For example, given the following module:\n\n```python\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef func(foo: str = typer.Option(\"bar\", help=\"What to foo\")) -\u003e None:\n    print(f\"{foo=}\")\n\nif __name__ == \"__main__\":\n    typer.run(func)\n```\n\n`foo` will be `\"bar\"` when the script is run as a command without any arguments, but if you call `func()` directly, you get:\n\n```\nfoo=\u003ctyper.models.OptionInfo object at 0x103414d60\u003e\n```\n\nThere's also the fact that typer doesn't support defining options as reusable decorators (EDIT: Well, you can do something like `REUSABLE_OPTION = typer.Option(\"default\", \"--reusable\", help=\"...\")` at the global level and then put `reusable_option: str = REUSABLE_OPTION` in all your command signatures.)  In a related vein, you can't use environment variables like `DANDI_DEVEL` to control whether an option exists.  The best ways I can think of to reimplement `DANDI_DEVEL` with typer are to either do something like this:\n\n```python\nif os.environ.get(\"DANDI_DEVEL\"):\n    @app.command()\n    def download(\n        ### all the public options go here\n        dandi_instance: str = typer.Option(\"dandi\", \"--dandi-instance, \"-i\"),\n        ### any other devel options go here\n    ):\n        _download(**public_options, **devel_options)\nelse:\n    @app.command()\n    def download(\n        ### all the public options again\n    ):\n        _download(**public_options, dandi_instance=\"dandi\", ...)\n```\n\nor just set the options' `hidden` configuration to `bool(os.environ.get(\"DANDI_DEVEL\"))` so that they are usable regardless of the value of `DANDI_DEVEL` but only show up in `--help` output when the envvar is set.","files":null},{"type":6,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1633558782,"metadata":{"github-id":"UCE_lALODBZtRc433ONizh4hfsk"},"target":"f865acbb0f32bbc2d67b929efa58a5b6b7f7e99c9222de4e28ed19a7abd52449","message":"@yarikoptic \n\n\u003e avoid duplication of params specification in decorators AND function signature\n\nTo an extent.  If you want to give an option both a long and a short form (like `-e`/`--existing`), typer requires you to write out the name of the option twice: `def func(existing: bool = typer.Option(False, \"-e\", \"--existing\"))`.\n\n\u003e provide both Python and CLI interfaces to the same functionality!\n\nOnly for the most trivial commands.  If you want an option to have something as simple as help text, you lose the ability to have a default argument when called like a function (regardless of whether you apply an `app = typer.Typer()` decorator or not).  For example, given the following module:\n\n```python\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef func(foo: str = typer.Option(\"bar\", help=\"What to foo\")) -\u003e None:\n    print(f\"{foo=}\")\n\nif __name__ == \"__main__\":\n    typer.run(func)\n```\n\n`foo` will be `\"bar\"` when the script is run as a command without any arguments, but if you call `func()` directly, you get:\n\n```\nfoo=\u003ctyper.models.OptionInfo object at 0x103414d60\u003e\n```\n\nThere's also the fact that typer doesn't support defining options as reusable decorators (EDIT: Well, you can do something like `REUSABLE_OPTION = typer.Option(\"default\", \"--reusable\", help=\"...\")` at the global level and then put `reusable_option: str = REUSABLE_OPTION` in all your command signatures.)  In a related vein, you can't use environment variables like `DANDI_DEVEL` to control whether an option exists.  The best ways I can think of to reimplement `DANDI_DEVEL` with typer are to either do something like this:\n\n```python\nif os.environ.get(\"DANDI_DEVEL\"):\n    @app.command()\n    def download(\n        ### all the public options go here\n        dandi_instance: str = typer.Option(\"dandi\", \"--dandi-instance, \"-i\"),\n        ### any other devel options go here\n    ):\n        _download(**public_options, **devel_options)\nelse:\n    @app.command()\n    def download(\n        ### all the public options again\n    ):\n        _download(**public_options, dandi_instance=\"dandi\", ...)\n```\n\nor just set the options' `hidden` configuration to `bool(os.environ.get(\"DANDI_DEVEL\"))` so that they are usable regardless of the value of `DANDI_DEVEL` but only show up in `--help` output when the envvar is set.\n\nEDIT: According to [this comment](https://github.com/tiangolo/typer/issues/296#issuecomment-869005608), it may be possible to create decorators for adding devel options using the \"merge-args\" library.","files":null},{"type":6,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1633561655,"metadata":{"github-id":"UCE_lALODBZtRc433ONizh4htmQ"},"target":"f865acbb0f32bbc2d67b929efa58a5b6b7f7e99c9222de4e28ed19a7abd52449","message":"@yarikoptic \n\n\u003e avoid duplication of params specification in decorators AND function signature\n\nTo an extent.  If you want to give an option both a long and a short form (like `-e`/`--existing`), typer requires you to write out the name of the option twice: `def func(existing: bool = typer.Option(False, \"-e\", \"--existing\"))`.\n\n\u003e provide both Python and CLI interfaces to the same functionality!\n\nOnly for the most trivial commands.  If you want an option to have something as simple as help text, you lose the ability to have a default argument when called like a function (regardless of whether you apply an `app = typer.Typer()` decorator or not).  For example, given the following module:\n\n```python\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef func(foo: str = typer.Option(\"bar\", help=\"What to foo\")) -\u003e None:\n    print(f\"{foo=}\")\n\nif __name__ == \"__main__\":\n    typer.run(func)\n```\n\n`foo` will be `\"bar\"` when the script is run as a command without any arguments, but if you call `func()` directly, you get:\n\n```\nfoo=\u003ctyper.models.OptionInfo object at 0x103414d60\u003e\n```\n\nEDIT: See this thread for workarounds: https://github.com/tiangolo/typer/issues/279\n\nThere's also the fact that typer doesn't support defining options as reusable decorators (EDIT: Well, you can do something like `REUSABLE_OPTION = typer.Option(\"default\", \"--reusable\", help=\"...\")` at the global level and then put `reusable_option: str = REUSABLE_OPTION` in all your command signatures.)  In a related vein, you can't use environment variables like `DANDI_DEVEL` to control whether an option exists.  The best ways I can think of to reimplement `DANDI_DEVEL` with typer are to either do something like this:\n\n```python\nif os.environ.get(\"DANDI_DEVEL\"):\n    @app.command()\n    def download(\n        ### all the public options go here\n        dandi_instance: str = typer.Option(\"dandi\", \"--dandi-instance, \"-i\"),\n        ### any other devel options go here\n    ):\n        _download(**public_options, **devel_options)\nelse:\n    @app.command()\n    def download(\n        ### all the public options again\n    ):\n        _download(**public_options, dandi_instance=\"dandi\", ...)\n```\n\nor just set the options' `hidden` configuration to `bool(os.environ.get(\"DANDI_DEVEL\"))` so that they are usable regardless of the value of `DANDI_DEVEL` but only show up in `--help` output when the envvar is set.\n\nEDIT: According to [this comment](https://github.com/tiangolo/typer/issues/296#issuecomment-869005608), it may be possible to create decorators for adding devel options using the \"merge-args\" library.","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1633573991,"metadata":{"github-id":"IC_kwDODBZtRc4334QK","github-url":"https://github.com/dandi/dandi-cli/issues/791#issuecomment-937395210"},"message":"Thank you @jwodder for a very fine cold shower ;)","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1637596150,"metadata":{"github-id":"IC_kwDODBZtRc46J2qP","github-url":"https://github.com/dandi/dandi-cli/issues/791#issuecomment-975661711"},"message":"with that in mind, let's just close","files":null},{"type":4,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1637596150,"metadata":{"github-id":"CE_lADODBZtRc48t8OXzwAAAAFREEdv"},"status":2}]}