{"version":2,"ops":[{"type":6,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1583114006,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDozNTU4MTE0NTg="},"target":"c1e0d494a6ead565a77faa4aa73f6d5588c5d90d7a4e76de8e4b39e50d315d77","message":"Ideally should be kept within .nwb itself (extension?) -- @bendichter could correct me if I am wrong, and I should just check later, but upon each save `pynwb` should regenerate UUID within a file.  We could then establish a trail of UUIDs for a file, not unlike git history where parent commit which contained previous version of the file is known.  This could provide a reliable mechanism for \"fast-forward\" updates to/from dandiarchive.  Any possible conflicts (divergence in the history of the trail, thus requiring a merge) would be beyond the scope here, although we could provide the tool to review the differences (if any) and accept one version or another or establish a \"merged\" one.\n\nedit 1: note that this is very .nwb specific, and wouldn't provide remedy for any other type of file we might need to allow upload to the archive.  general solution would be to use VCS-based system IMHO.","files":null},{"type":6,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1583114023,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDozNTU4MTE1MTM="},"target":"c1e0d494a6ead565a77faa4aa73f6d5588c5d90d7a4e76de8e4b39e50d315d77","message":"Ideally should be kept within .nwb itself (extension?) -- @bendichter could correct me if I am wrong, and I should just check later, but upon each save `pynwb` should regenerate UUID within a file.  We could then establish a trail of UUIDs for a file, not unlike git history where parent commit which contained previous version of the file is known.  This could provide a reliable mechanism for \"fast-forward\" updates to/from dandiarchive.  Any possible conflicts (divergence in the history of the trail, thus requiring a merge) would be beyond the scope here, although we could provide the tool to review the differences (if any) and accept one version or another or establish a \"merged\" one.\n\nedit 1: note that this is very .nwb specific, and wouldn't provide remedy for any other type of file we might need to allow upload to the archive.  general solution  IMHO would be to use VCS-based platform.","files":null},{"type":6,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1583114055,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDozNTU4MTE1NzI="},"target":"c1e0d494a6ead565a77faa4aa73f6d5588c5d90d7a4e76de8e4b39e50d315d77","message":"Ideally should be kept within .nwb itself (extension?) -- @bendichter could correct me if I am wrong, and I should just check later, but upon each save `pynwb` should regenerate UUID within a file.  We could then establish a trail of UUIDs for a file, not unlike git history where parent commit which contained previous version of the file is known.  This could provide a reliable mechanism for \"fast-forward only\" updates to/from dandiarchive.  Any possible conflicts (divergence in the history of the trail, thus requiring a merge) would be beyond the scope here, although we could provide the tool to review the differences (if any) and accept one version or another or establish a \"merged\" one.\n\nedit 1: note that this is very .nwb specific, and wouldn't provide remedy for any other type of file we might need to allow upload to the archive.  general solution  IMHO would be to use VCS-based platform.","files":null}]}