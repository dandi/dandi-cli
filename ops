{"version":2,"ops":[{"type":6,"author":{"id":"12cb25e6e3f19b53447b05d00d7d4d53c925c908"},"timestamp":1669124340,"metadata":{"github-id":"UCE_lAHODBZtRc5W9uWJzjeVW5I"},"target":"5fc31c80e2ba5d7094fbdb51dac375a86ef71f1049da37a7af4aee6df7cbb21a","message":"it seems that some aspects of dandiset naming/layout may be falling through the cracks. here is another example: https://dandiarchive.org/dandiset/000168/draft\n\nas part of healthcheck if may be worthwhile considering if files should have a different name, but doesn't. this could capture a few things: 1) dandisets like this one, 2) dandisets that were uploaded in parts, and may need name resolution before upload.","files":null},{"type":5,"author":{"id":"12cb25e6e3f19b53447b05d00d7d4d53c925c908"},"timestamp":1670167470,"metadata":{"github-id":"LE_lADODBZtRc5W9uWJzwAAAAHZxiOp"},"added":["bug"],"removed":[]},{"type":2,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1670253933,"metadata":{"github-id":"RTE_lADODBZtRc5W9uWJzwAAAAHaOOro"},"title":"upload doesn't seem to be checking for valid DANDI (when not BIDS) organization of files/assets","was":"upload doesn't seem to be checking for valid DANDI (when not BIDS) organization of files/assets"},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1670254712,"metadata":{"github-id":"IC_kwDODBZtRc5PugRp","github-url":"https://github.com/dandi/dandi-cli/issues/1163#issuecomment-1337590889"},"message":"Per our brief discussion and possibly with my biased view over the situation, the first step would be to add to `validate` procedure for files which are not in BIDS dandiset, to conform our DANDI files layout which is at large conforming the description within https://github.com/dandi/dandi-cli/blob/master/dandi/cli/cmd_organize.py#L67 docstring and implemented in https://github.com/dandi/dandi-cli/blob/master/dandi/organize.py . \n\nAt large it is the fact that asset path should conform to `sub-{labelregex}/sub-{labelregex}(_{entity}-{labelregex})*_{suffix}{extension}` with also a check (separate dedicated error record) if `sub-{labelregex}` is identical within folder and file path.\n\nhttps://github.com/dandi/dandi-cli/blob/master/dandi/organize.py#L397 `_sanitize_value` is the function which shows which charaters aren't allowed in `{labelregex}`.\n\nAssigning to @jwodder to make it woven it in current logic on deciding either it is within BIDS  or DANDI layout.","files":null},{"type":3,"author":{"id":"12cb25e6e3f19b53447b05d00d7d4d53c925c908"},"timestamp":1670256662,"metadata":{"github-id":"IC_kwDODBZtRc5PusUW","github-url":"https://github.com/dandi/dandi-cli/issues/1163#issuecomment-1337640214"},"message":"inded, as a first pass a more generic regex would work and should be implemented.","files":null},{"type":6,"author":{"id":"12cb25e6e3f19b53447b05d00d7d4d53c925c908"},"timestamp":1670256669,"metadata":{"github-id":"UCE_lALODBZtRc5PusUWzipPSSA"},"target":"2e980cc63be7ac533268a1093290a08fbf453e67a6f849747cf03364ae49c16c","message":"indeed, as a first pass a more generic regex would work and should be implemented.","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1670853439,"metadata":{"github-id":"IC_kwDODBZtRc5QQtGH","github-url":"https://github.com/dandi/dandi-cli/issues/1163#issuecomment-1346556295"},"message":"@yarikoptic \n\n* This check should only apply to NWB files that are not in BIDS datasets, correct?\n* What is the format for the `{suffix}` field in the pattern in your last comment?\n* To be clear, this check should produce two validation errors — one for not following the pattern, another for when the folder and filename start with different `sub-{labelregex}` segments — where the fields of the `ValidationResult` are:\n\n    * `id`: ???\n    * `origin`: `ValidationOrigin(name=\"dandi\", version=dandi.__version__)`\n    * `severity`: `Severity.ERROR`\n    * `scope`: `Scope.FILE`\n    * `path`: filepath of the asset\n    * `asset_paths`: `None`\n    * `within_asset_paths`: `None`\n    * `dandiset_path`: path to root of Dandiset\n    * `dataset_path`: `None` ?\n    * `message`: ???\n    * `metadata`: ???\n    * `path_regex`: `None`","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1670857260,"metadata":{"github-id":"IC_kwDODBZtRc5QRF7u","github-url":"https://github.com/dandi/dandi-cli/issues/1163#issuecomment-1346658030"},"message":"\u003e @yarikoptic\n\u003e \n\u003e * This check should only apply to NWB files that are not in BIDS datasets, correct?\n\nshort answer: yes, for starters it would apply only to NWB files.\n\nLonger answer: eventually it should apply not only to .nwb files but also other data types, e.g. those video files we allow being referenced within NWB files and referencing in `VIDEO_FILE_EXTENSIONS`, and possibly other file formats.   I just don't know if we decided on the exact file naming for those yet.\n\n\u003e * What is the format for the `{suffix}` field in the pattern in your last comment?\n\nin `organize` ATM we build it  https://github.com/dandi/dandi-cli/blob/HEAD/dandi/organize.py#L377\n```\n                if isinstance(value, (list, tuple)):\n                    value = \"+\".join(map(str, value))\n```\n\nso let's make it smth like `[a-z]+(\\+[a-z]+)*` ? (I don't think we ATM allow/have any upper case or digits)\n\n\u003e * To be clear, this check should produce two validation errors — one for not following the pattern, another for when the folder and filename start with different `sub-{labelregex}` segments \n\nyes...\n\n\u003cdetails\u003e\n\u003csummary\u003eFWIW - here is current ids we have for validation results (I am leaning toward standardizing them all to be upper case so there is no thought needed on how to case them). We might want to adjust them later as well in terms of names to make them more analogous across BIDS and DANDI\u003c/summary\u003e \n\n```shell\n❯ git grep \"\\\u003cid=[\\\"']\"\ndandi/files/bases.py:                        id=\"dandischema.TODO\",\ndandi/files/bases.py:                        id=\"dandi.SOFTWARE_ERROR\",\ndandi/files/bases.py:                    id=\"dandischema.requred_field\",\ndandi/files/bases.py:                    id=\"dandischema.placeholder_value\",\ndandi/files/zarr.py:                    id=\"zarr.cannot_open\",\ndandi/files/zarr.py:                    id=\"zarr.empty_group\",\ndandi/files/zarr.py:                    id=\"zarr.tree_depth_exceeded\",\ndandi/pynwb_utils.py:                    id=\"pywnb.GENERIC\",\ndandi/validate.py:                id=\"BIDS.NON_BIDS_PATH_PLACEHOLDER\",\ndandi/validate.py:                    id=\"BIDS.MANDATORY_FILE_MISSING_PLACEHOLDER\",\ndandi/validate.py:                id=\"BIDS.MATCH\",\n\n```\n\u003c/details\u003e\n\nso let's make  3 of them\n- `DANDI.NON_DANDI_FILENAME` - when file is not following the pattern,\n- `DANDI.NON_DANDI_FOLDERNAME` - when folder is either not present (file flat in the top) or wrong level (e.g. `dir1/dir2/filename`) or not following `sub-{subject}` regex \n- `DANDI.METADATA_MISMATCH_SUBJECT` -- I foresee more of similar `METADATA_MISMATCH` errors in the future.  That is when filename subject is different from folder subject.  If any previous error already in place for that path -- avoid this check.\n\n\u003e — where the fields of the `ValidationResult` are:\n   \n\u003e   * `id`: ???\n\nabove 3 ids\n\n\u003e   * `origin`: `ValidationOrigin(name=\"dandi\", version=dandi.__version__)`\n\u003e   * `severity`: `Severity.ERROR`\n\u003e   * `scope`: `Scope.FILE`\n\nLet's add Scope `FOLDER` for `DANDI.NON_DANDI_FOLDERNAME`\n\n\u003e   * `path`: filepath of the asset\n\nor folder if defined (not empty)\n\n\u003e   * `asset_paths`: `None`\n\nok, but might later be all the files under folder for `DANDI.NON_DANDI_FOLDERNAME`\n\n\u003e   * `within_asset_paths`: `None`\n\u003e   * `dandiset_path`: path to root of Dandiset\n\u003e   * `dataset_path`: `None` ?\n\u003e   * `message`: ???\n\nshort description of the error\n\n\u003e   * `metadata`: ???\n\nparse similarly to how done for BIDS ones for `DANDI.METADATA_MISMATCH_SUBJECT` and `DANDI.NON_DANDI_FILENAME`\n\n\u003e   * `path_regex`: `None`\n\nI think so although for `DANDI.NON_DANDI_FILENAME` if you implement it via regex -- add that regex here","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1670858021,"metadata":{"github-id":"IC_kwDODBZtRc5QRK54","github-url":"https://github.com/dandi/dandi-cli/issues/1163#issuecomment-1346678392"},"message":"@yarikoptic \n\n\u003e Let's add Scope `FOLDER` for `DANDI.NON_DANDI_FOLDERNAME`\n\nI don't think that makes much sense, as that would really only be appropriate if validation was run on individual folders, yet it's instead run on files (and Dandisets \u0026 datasets as a whole).\n\n\u003e \u003e * `metadata`: ???\n\u003e\n\u003e parse similarly to how done for BIDS ones for `DANDI.METADATA_MISMATCH_SUBJECT` and `DANDI.NON_DANDI_FILENAME`\n\nThe only BIDS validation result that sets `metadata` is `BIDS.MATCH`, which gets its metadata from the `match_listing` field of the structure returned by bidsschematools.","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1670861297,"metadata":{"github-id":"IC_kwDODBZtRc5QRo8-","github-url":"https://github.com/dandi/dandi-cli/issues/1163#issuecomment-1346801470"},"message":"@yarikoptic Problem: The `validate` command now needs to determine the root of the Dandiset(s) being validated in order to properly calculate the assets' relative paths.  How should this be done, taking into account that `validate` can accept many paths that (currently) need not belong to the same Dandiset?","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1670865319,"metadata":{"github-id":"IC_kwDODBZtRc5QSC1W","github-url":"https://github.com/dandi/dandi-cli/issues/1163#issuecomment-1346907478"},"message":"\u003e @yarikoptic\n\u003e \n\u003e \u003e Let's add Scope `FOLDER` for `DANDI.NON_DANDI_FOLDERNAME`\n\u003e \n\u003e I don't think that makes much sense, as that would really only be appropriate if validation was run on individual folders, yet it's instead run on files (and Dandisets \u0026 datasets as a whole).\n\nThe `scope` is not about what validation is ran on -- but about the level/entity what that error is *applicable to*. E.g. we can have error of scope of a `DATASET` when it is ran on dandiset which is BIDS dataset with subdatasets and some specific subdataset has an error. \nSo in principle `FOLDER` scope does make sense to me. Indeed though we do not have notion of `Folder` in assets, but we do organize into folders and even return folders in listing. The question/problem is that we would have 1 such error for each asset under that folder. We might need to have some post processing function which would join multiple such errors of scope folder into one for that specific folder path, and thus appending all the `asset_paths` into a single list within that combined error.\n\n\u003e \u003e \u003e * `metadata`: ???\n\u003e \u003e \n\u003e \u003e \n\u003e \u003e parse similarly to how done for BIDS ones for `DANDI.METADATA_MISMATCH_SUBJECT` and `DANDI.NON_DANDI_FILENAME`\n\u003e \n\u003e The only BIDS validation result that sets `metadata` is `BIDS.MATCH`, which gets its metadata from the `match_listing` field of the structure returned by bidsschematools.\n\nyeap, because it was the only process which relied on regexes. If you rely on regexes -- here you can tell which regex was not matched.\n\n\u003e @yarikoptic Problem: The `validate` command now needs to determine the root of the Dandiset(s) being validated in order to properly calculate the assets' relative paths. How should this be done, taking into account that `validate` can accept many paths that (currently) need not belong to the same Dandiset?\n\nup to you -- since we have `dandiset` field -- we can in principle get a list of validation results where they would \"belong\" to different dandisets.  Or it is ok to just error out and require paths for a single dandiset for `validate` invocation if you see the need for that ATM.","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1670865465,"metadata":{"github-id":"IC_kwDODBZtRc5QSDuJ","github-url":"https://github.com/dandi/dandi-cli/issues/1163#issuecomment-1346911113"},"message":"@yarikoptic I'm unclear what you want the `metadata` fields of the `ValidationResult`s set to.","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1670870712,"metadata":{"github-id":"IC_kwDODBZtRc5QSo91","github-url":"https://github.com/dandi/dandi-cli/issues/1163#issuecomment-1347063669"},"message":"@yarikoptic \n\n\u003e up to you -- since we have `dandiset` field -- we can in principle get a list of validation results where they would \"belong\" to different dandisets.\n\nIf you're referring to the `dandiset_path` field in `ValidationResult`, that's currently not filled in by anything, as assets currently don't store the path to the root of their Dandiset.\n\nRegardless, I think the simplest option is to use `find_parent_directory_containing()` to locate the Dandiset root for each path passed to `validate`, but the question then becomes, what should happen if a path is not inside a Dandiset?  Should there be a dedicated `ValidationResult` error for that?","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1670880926,"metadata":{"github-id":"IC_kwDODBZtRc5QTzX2","github-url":"https://github.com/dandi/dandi-cli/issues/1163#issuecomment-1347368438"},"message":"\u003e @yarikoptic I'm unclear what you want the `metadata` fields of the `ValidationResult`s set to.\n\nok, don't set to anything for now -- it seems we have not described/formalized what kind of metadata we want to see there so to not confuse more (since we already have all *kinds* of metadata) -- omit setting that one.\n\n\u003e @yarikoptic\n\u003e \n\u003e \u003e up to you -- since we have `dandiset` field -- we can in principle get a list of validation results where they would \"belong\" to different dandisets.\n\u003e \n\u003e If you're referring to the `dandiset_path` field in `ValidationResult`, that's currently not filled in by anything, as assets currently don't store the path to the root of their Dandiset.\n\nthat is ok, code which calls validation would know dandiset those assets belong to, right? so that code could set `dandiset_path` in the provided to it records appropriately.\n\n\u003e what should happen if a path is not inside a Dandiset? Should there be a dedicated `ValidationResult` error for that?\n\ngood question. We did allow for use of `dandi validate` on some individual .nwb files.  I think if there is no dandiset boundary found (directory with `dandiset.yaml`) neither of the tests described in this issue are pertinent.  We should just issue a ValidationResult record with id `DANDI.NO_DANDISET_FOUND` and skip testing any of those 3 tests, thus possibly just running tests pertinent to .nwb file (or BIDS dataset). Later we could add ability to skip/suppress specific errors (ids).","files":null},{"type":3,"author":{"id":"364914f8b1c8a9131d300bf2978e4ffe2ff1aeeb"},"timestamp":1670881519,"metadata":{"github-id":"IC_kwDODBZtRc5QT3Rt","github-url":"https://github.com/dandi/dandi-cli/issues/1163#issuecomment-1347384429"},"message":"@yarikoptic \n\n\u003e I think if there is no dandiset boundary found (directory with `dandiset.yaml`) neither of the tests described in this issue are pertinent. We should just issue a ValidationResult record with id `DANDI.NO_DANDISET_FOUND` and skip testing any of those 3 tests, thus possibly just running tests pertinent to .nwb file (or BIDS dataset).\n\nThe code isn't structured in a way to make that reasonable.  All validation of an asset happens in the `DandiFile.get_validation_errors()` method, and obtaining a `DandiFile` happens after the calling code either determines the Dandiset root or leaves it unset.  A `DandiFile` automatically assumes that it belongs to a Dandiset and that its `path` attribute is the path to that asset from the root of the Dandiset.","files":null},{"type":3,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1670884257,"metadata":{"github-id":"IC_kwDODBZtRc5QUDQQ","github-url":"https://github.com/dandi/dandi-cli/issues/1163#issuecomment-1347433488"},"message":"\u003e after the calling code either determines the Dandiset root or leaves it unset.\n\nso here we go -- if there is no root - no need for this checks in the 'calling code'. If there is root -- do the checks and add that `Dandiset root` into returned records.","files":null},{"type":4,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1671053183,"metadata":{"github-id":"CE_lADODBZtRc5W9uWJzwAAAAHfUiJ3"},"status":2}]}