{"version":2,"ops":[{"type":3,"author":{"id":"12cb25e6e3f19b53447b05d00d7d4d53c925c908"},"timestamp":1611191695,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDc2NDE0OTQwNQ==","github-url":"https://github.com/dandi/dandi-cli/issues/333#issuecomment-764149405"},"message":"thanks @yarikoptic  for this detailed issue.  there are a few additional things - this is true in json schema as well, not just pydantic, where you can specifiy union of allowed types in the schema.  unfortunately there is no type information in the data itself. the validator then can determine if the data fits any of the schemas.  one thing we can do is to add \"type\" (as is the case in jsonld) as a property in every object and make this a readonly value.   here is the schema.org jsonld example for book with identifier.\n\n```json\n{\n \"@context\": \"https://schema.org/\",\n \"@type\": \"Book\",\n \"name\": \"Library linked data in the cloud : OCLC's experiments with new models of resource description\",\n \"author\": \"Carol Jean Godby\",\n \"isbn\": \"9781627052191\"\n \"identifier\": {\n \"@type\": \"PropertyValue\",\n   \"propertyID\": \"OCoLC\",\n   \"value\":  \"889647468\"\n   },\n \"sameAs\": \"http://www.worldcat.org/oclc/889647468\"\n}\n```\n\nthis will not address trivial types like AnyURL and str, but should handle the more complex types.","files":null},{"type":3,"author":{"id":"1d7d442aa1925df5e89cbf71d597eb72205cfee1"},"timestamp":1611766095,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDc2ODQwMzg4Ng==","github-url":"https://github.com/dandi/dandi-cli/issues/333#issuecomment-768403886"},"message":"The relevant notion we are dancing around here is that of the [tagged union](https://en.wikipedia.org/wiki/Tagged_union). Unfortunately, it seems that pydantic [explicitly doesn't yet support this](https://github.com/samuelcolvin/pydantic/issues/619). Here is [someone's attempt](https://stackoverflow.com/questions/62529877/pydantic-validate-discriminated-union-with-literals) at a custom validator for Pydantic that uses `Literal` values to act as the type tag.\n\nI only have rather vague advice for this situation, which boils down to: let's keep things as simple as possible. In this case, simplicity meshes with explicitness (making it a twofer in terms of [Python Zen](https://www.python.org/dev/peps/pep-0020/#the-zen-of-python)), requiring something like a `@type` field uniformly on all models. It is explicit for obvious reasons, and simply because it makes type detection a uniform problem across all models.\n\nIt may feel wrong because we shouldn't have to do it, and it makes the schemata themselves bulkier, but IMO that would be made up for by forcing the extra complexity on the machine, and detaching it from our human selves (keeping in mind that we are trying, as a design goal, not to expose DANDI users to the raw schemata). I believe this would also allow an easier path to UI customization (should that be necessary).","files":null},{"type":6,"author":{"id":"1d7d442aa1925df5e89cbf71d597eb72205cfee1"},"timestamp":1611766095,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6NDMwMTMzMjA3"},"target":"9048470ec696d90f20b4f8a816399d1375d3a9c01e32944f4be54040f7aafada","message":"The relevant notion we are dancing around here is that of the [tagged union](https://en.wikipedia.org/wiki/Tagged_union). Unfortunately, it seems that pydantic [explicitly doesn't yet support this](https://github.com/samuelcolvin/pydantic/issues/619). Here is [someone's attempt](https://stackoverflow.com/questions/62529877/pydantic-validate-discriminated-union-with-literals) at a custom validator for Pydantic that uses `Literal` values to act as the type tag.\n\nI only have rather vague advice for this situation, which boils down to: let's keep things as simple as possible. In this case, simplicity meshes with explicitness (making it a twofer in terms of [Python Zen](https://www.python.org/dev/peps/pep-0020/#the-zen-of-python)), requiring something like a `@type` field uniformly on all models. It is explicit for obvious reasons, and simple because it makes type detection a uniform problem across all models.\n\nIt may feel wrong because we shouldn't have to do it, and it makes the schemata themselves bulkier, but IMO that would be made up for by forcing the extra complexity on the machine, and detaching it from our human selves (keeping in mind that we are trying, as a design goal, not to expose DANDI users to the raw schemata). I believe this would also allow an easier path to UI customization (should that be necessary).","files":null},{"type":3,"author":{"id":"be5d9cd197657770bbbabb5faa204fd4dcdcba01"},"timestamp":1611766916,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDc2ODQyNzkxNw==","github-url":"https://github.com/dandi/dandi-cli/issues/333#issuecomment-768427917"},"message":"Just want to point out that it's important that if we are going to include a type tags on unions, it specifically needs to be e.g.\n\n```\nschemaKey: anatomy\n```\n\nin order for the client UI component to recognize it first hand. Otherwise, we'd still have to transform the schema on the client, which is not something we want to do.","files":null},{"type":3,"author":{"id":"12cb25e6e3f19b53447b05d00d7d4d53c925c908"},"timestamp":1611770238,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDc2ODQ2NDYyOA==","github-url":"https://github.com/dandi/dandi-cli/issues/333#issuecomment-768464628"},"message":"@AlmightyYakob and @waxlamp - i did a bunch of work on this yesterday to better understand the issues and i'm getting closer to a newer model. indeed certain specific types of union are what is causing trouble. not all unions. and the other piece is the union in identifier. i hope to resolve both of these things today or by tomorrow.","files":null}]}