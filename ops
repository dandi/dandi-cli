{"version":2,"ops":[{"type":1,"author":{"id":"cac198dcaca68fe02c5f855e68c71695554017cc"},"timestamp":1719434012,"metadata":{"github-id":"I_kwDODBZtRc6Nr70O","github-url":"https://github.com/dandi/dandi-cli/issues/1455","origin":"github"},"title":"\"Incorrect password\" when trying to download embargoed file","message":"I am running a notebook on dandihub and trying to download an embargoed file that I have access to. Even when providing my dandi api key, I get a prompt to enter a keyring password. I don't know where to find such a password.\n\n```python\nnwbs = []\nfile = dandiset.get_asset_by_path(dandi_filepath)\nfile_url = file.download_url\n\nfilename = dandi_filepath.split(\"/\")[-1]\nfilepath = f\"{download_loc}/{filename}\"\n\ndownload.download(file_url, output_dir=download_loc)\nprint(f\"Downloaded file to {filepath}\")\n\nprint(\"Opening file\")\nio = NWBHDF5IO(filepath, mode=\"r\", load_namespaces=True)\nnwbs.append(io.read())\n```\n\nAnd the error (After entering an empty password to the keyring prompt):\n```\n---------------------------------------------------------------------------\nHTTPError                                 Traceback (most recent call last)\nFile /opt/conda/lib/python3.11/site-packages/dandi/dandiarchive.py:170, in ParsedDandiURL.navigate(self, strict, authenticate)\n    169 try:\n--\u003e 170     dandiset = self.get_dandiset(client, lazy=not strict)\n    171 except requests.HTTPError as e:\n\nFile /opt/conda/lib/python3.11/site-packages/dandi/dandiarchive.py:107, in ParsedDandiURL.get_dandiset(self, client, lazy)\n    106 if self.dandiset_id is not None:\n--\u003e 107     return client.get_dandiset(self.dandiset_id, self.version_id, lazy=lazy)\n    108 else:\n\nFile /opt/conda/lib/python3.11/site-packages/dandi/dandiapi.py:546, in DandiAPIClient.get_dandiset(self, dandiset_id, version_id, lazy)\n    544 try:\n    545     d = RemoteDandiset.from_data(\n--\u003e 546         self, self.get(f\"/dandisets/{dandiset_id}/\")\n    547     )\n    548 except HTTP404Error:\n\nFile /opt/conda/lib/python3.11/site-packages/dandi/dandiapi.py:300, in RESTFullAPIClient.get(self, path, **kwargs)\n    297 \"\"\"\n    298 Convenience method to call `request()` with the 'GET' HTTP method.\n    299 \"\"\"\n--\u003e 300 return self.request(\"GET\", path, **kwargs)\n\nFile /opt/conda/lib/python3.11/site-packages/dandi/dandiapi.py:276, in RESTFullAPIClient.request(self, method, path, params, data, files, json, headers, json_resp, retry_statuses, retry_if, **kwargs)\n    275     else:\n--\u003e 276         raise requests.HTTPError(msg, response=result)\n    278 if json_resp:\n\nHTTPError: Error 401 while sending GET request to https://api.dandiarchive.org/api/dandisets/000336/: {\"detail\":\"Authentication credentials were not provided.\"}\n\nDuring handling of the above exception, another exception occurred:\n\nAssertionError                            Traceback (most recent call last)\nFile /opt/conda/lib/python3.11/site-packages/keyrings/alt/file.py:188, in EncryptedKeyring._unlock(self)\n    187 try:\n--\u003e 188     ref_pw = self.get_password('keyring-setting', 'password reference')\n    189     assert ref_pw == 'password reference value'\n\nFile /opt/conda/lib/python3.11/site-packages/keyrings/alt/file_base.py:108, in Keyring.get_password(self, service, username)\n    107 try:\n--\u003e 108     password = self.decrypt(password_encrypted, assoc).decode('utf-8')\n    109 except ValueError:\n    110     # decrypt the password without associated data\n\nFile /opt/conda/lib/python3.11/site-packages/keyrings/alt/file.py:220, in EncryptedKeyring.decrypt(self, password_encrypted, assoc)\n    219 plaintext = cipher.decrypt(data['password_encrypted'])\n--\u003e 220 assert plaintext.startswith(self.pw_prefix)\n    221 return plaintext[3:]\n\nAssertionError: \n\nDuring handling of the above exception, another exception occurred:\n\nValueError                                Traceback (most recent call last)\nFile /opt/conda/lib/python3.11/site-packages/keyrings/alt/file_base.py:108, in Keyring.get_password(self, service, username)\n    107 try:\n--\u003e 108     password = self.decrypt(password_encrypted, assoc).decode('utf-8')\n    109 except ValueError:\n    110     # decrypt the password without associated data\n\nFile /opt/conda/lib/python3.11/site-packages/keyrings/alt/file.py:218, in EncryptedKeyring.decrypt(self, password_encrypted, assoc)\n    217     data[key] = decodebytes(data[key].encode())\n--\u003e 218 cipher = self._create_cipher(self.keyring_key, data['salt'], data['IV'])\n    219 plaintext = cipher.decrypt(data['password_encrypted'])\n\nFile /opt/conda/lib/python3.11/site-packages/jaraco/classes/properties.py:75, in NonDataProperty.__get__(self, obj, objtype)\n     74     return self\n---\u003e 75 return self.fget(obj)\n\nFile /opt/conda/lib/python3.11/site-packages/keyrings/alt/file.py:100, in EncryptedKeyring.keyring_key(self)\n     99 if self._check_file():\n--\u003e 100     self._unlock()\n    101 else:\n\nFile /opt/conda/lib/python3.11/site-packages/keyrings/alt/file.py:192, in EncryptedKeyring._unlock(self)\n    191 self._lock()\n--\u003e 192 raise ValueError(\"Incorrect Password\")\n\nValueError: Incorrect Password\n\nDuring handling of the above exception, another exception occurred:\n\nAssertionError                            Traceback (most recent call last)\nFile /opt/conda/lib/python3.11/site-packages/keyrings/alt/file.py:188, in EncryptedKeyring._unlock(self)\n    187 try:\n--\u003e 188     ref_pw = self.get_password('keyring-setting', 'password reference')\n    189     assert ref_pw == 'password reference value'\n\nFile /opt/conda/lib/python3.11/site-packages/keyrings/alt/file_base.py:108, in Keyring.get_password(self, service, username)\n    107 try:\n--\u003e 108     password = self.decrypt(password_encrypted, assoc).decode('utf-8')\n    109 except ValueError:\n    110     # decrypt the password without associated data\n\nFile /opt/conda/lib/python3.11/site-packages/keyrings/alt/file.py:220, in EncryptedKeyring.decrypt(self, password_encrypted, assoc)\n    219 plaintext = cipher.decrypt(data['password_encrypted'])\n--\u003e 220 assert plaintext.startswith(self.pw_prefix)\n    221 return plaintext[3:]\n\nAssertionError: \n\nDuring handling of the above exception, another exception occurred:\n\nValueError                                Traceback (most recent call last)\nCell In[10], line 14\n     11 filename = dandi_filepath.split(\"/\")[-1]\n     12 filepath = f\"{download_loc}/{filename}\"\n---\u003e 14 download.download(file_url, output_dir=download_loc)\n     15 print(f\"Downloaded file to {filepath}\")\n     17 print(\"Opening file\")\n\nFile /opt/conda/lib/python3.11/site-packages/dandi/download.py:164, in download(urls, output_dir, format, existing, jobs, jobs_per_zarr, get_metadata, get_assets, sync, path_type)\n    162 elif format is DownloadFormat.PYOUT:\n    163     with out:\n--\u003e 164         for rec in gen_:\n    165             out(rec)\n    166 else:\n\nFile /opt/conda/lib/python3.11/site-packages/dandi/download.py:151, in \u003cgenexpr\u003e(.0)\n    131         lgr.warning(\n    132             \"Parallel downloads are not yet implemented for non-pyout format=%r. \"\n    133             \"Download will proceed serially.\",\n    134             str(format),\n    135         )\n    137 downloaders = [\n    138     Downloader(\n    139         url=purl,\n   (...)\n    148     for purl in parsed_urls\n    149 ]\n--\u003e 151 gen_ = (r for dl in downloaders for r in dl.download_generator())\n    153 # TODOs:\n    154 #  - redo frontends similarly to how command_ls did it\n    155 #  - have a single loop with analysis of `rec` to either any file\n    156 #    has failed to download.  If any was: exception should probably be\n    157 #    raised.  API discussion for Python side of API:\n    158 #\n    159 if format is DownloadFormat.DEBUG:\n\nFile /opt/conda/lib/python3.11/site-packages/dandi/download.py:235, in Downloader.download_generator(self)\n    224 def download_generator(self) -\u003e Iterator[dict]:\n    225     \"\"\"\n    226     A generator for downloads of files, folders, or entire dandiset from\n    227     DANDI (as identified by URL)\n   (...)\n    232     schema) while validating their checksums \"on the fly\", etc.\n    233     \"\"\"\n--\u003e 235     with self.url.navigate(strict=True) as (client, dandiset, assets):\n    236         if (\n    237             isinstance(self.url, DandisetURL)\n    238             or (\n   (...)\n    241             )\n    242         ) and self.get_metadata:\n    243             assert dandiset is not None\n\nFile /opt/conda/lib/python3.11/contextlib.py:137, in _GeneratorContextManager.__enter__(self)\n    135 del self.args, self.kwds, self.func\n    136 try:\n--\u003e 137     return next(self.gen)\n    138 except StopIteration:\n    139     raise RuntimeError(\"generator didn't yield\") from None\n\nFile /opt/conda/lib/python3.11/site-packages/dandi/dandiarchive.py:178, in ParsedDandiURL.navigate(self, strict, authenticate)\n    172 if (\n    173     e.response is not None\n    174     and e.response.status_code == 401\n    175     and authenticate is not False\n    176 ):\n    177     lgr.info(\"Resource requires authentication; authenticating ...\")\n--\u003e 178     client.dandi_authenticate()\n    179     dandiset = self.get_dandiset(client, lazy=not strict)\n    180 else:\n\nFile /opt/conda/lib/python3.11/site-packages/dandi/dandiapi.py:495, in DandiAPIClient.dandi_authenticate(self)\n    493     return\n    494 client_name, app_id = self._get_keyring_ids()\n--\u003e 495 keyring_backend, api_key = keyring_lookup(app_id, \"key\")\n    496 key_from_keyring = api_key is not None\n    497 while True:\n\nFile /opt/conda/lib/python3.11/site-packages/dandi/keyring.py:29, in keyring_lookup(service_name, username)\n     22 def keyring_lookup(\n     23     service_name: str, username: str\n     24 ) -\u003e tuple[KeyringBackend, str | None]:\n     25     \"\"\"\n     26     Returns an appropriate keyring backend and the password it holds (if any)\n     27     for the given service and username.\n     28     \"\"\"\n---\u003e 29     return keyring_op(lambda kb: kb.get_password(service_name, username))\n\nFile /opt/conda/lib/python3.11/site-packages/dandi/keyring.py:97, in keyring_op(func)\n     95 kb = get_keyring()\n     96 try:\n---\u003e 97     return (kb, func(kb))\n     98 except KeyringError as e:\n     99     lgr.info(\"Default keyring errors on query: %s\", e)\n\nFile /opt/conda/lib/python3.11/site-packages/dandi/keyring.py:29, in keyring_lookup.\u003clocals\u003e.\u003clambda\u003e(kb)\n     22 def keyring_lookup(\n     23     service_name: str, username: str\n     24 ) -\u003e tuple[KeyringBackend, str | None]:\n     25     \"\"\"\n     26     Returns an appropriate keyring backend and the password it holds (if any)\n     27     for the given service and username.\n     28     \"\"\"\n---\u003e 29     return keyring_op(lambda kb: kb.get_password(service_name, username))\n\nFile /opt/conda/lib/python3.11/site-packages/keyring/backends/chainer.py:48, in ChainerBackend.get_password(self, service, username)\n     46 def get_password(self, service, username):\n     47     for keyring in self.backends:\n---\u003e 48         password = keyring.get_password(service, username)\n     49         if password is not None:\n     50             return password\n\nFile /opt/conda/lib/python3.11/site-packages/keyrings/alt/file_base.py:111, in Keyring.get_password(self, service, username)\n    108         password = self.decrypt(password_encrypted, assoc).decode('utf-8')\n    109     except ValueError:\n    110         # decrypt the password without associated data\n--\u003e 111         password = self.decrypt(password_encrypted).decode('utf-8')\n    112 except (configparser.NoOptionError, configparser.NoSectionError):\n    113     password = None\n\nFile /opt/conda/lib/python3.11/site-packages/keyrings/alt/file.py:218, in EncryptedKeyring.decrypt(self, password_encrypted, assoc)\n    216 for key in data:\n    217     data[key] = decodebytes(data[key].encode())\n--\u003e 218 cipher = self._create_cipher(self.keyring_key, data['salt'], data['IV'])\n    219 plaintext = cipher.decrypt(data['password_encrypted'])\n    220 assert plaintext.startswith(self.pw_prefix)\n\nFile /opt/conda/lib/python3.11/site-packages/jaraco/classes/properties.py:75, in NonDataProperty.__get__(self, obj, objtype)\n     73 if obj is None:\n     74     return self\n---\u003e 75 return self.fget(obj)\n\nFile /opt/conda/lib/python3.11/site-packages/keyrings/alt/file.py:100, in EncryptedKeyring.keyring_key(self)\n     96 @properties.NonDataProperty\n     97 def keyring_key(self):\n     98     # _unlock or _init_file will set the key or raise an exception\n     99     if self._check_file():\n--\u003e 100         self._unlock()\n    101     else:\n    102         self._init_file()\n\nFile /opt/conda/lib/python3.11/site-packages/keyrings/alt/file.py:192, in EncryptedKeyring._unlock(self)\n    190 except AssertionError:\n    191     self._lock()\n--\u003e 192     raise ValueError(\"Incorrect Password\")\n\nValueError: Incorrect Password\n```","files":null}]}