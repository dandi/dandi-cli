{"version":2,"ops":[{"type":1,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1608062021,"metadata":{"github-id":"MDU6SXNzdWU3NjgxMTM1NzQ=","github-url":"https://github.com/dandi/dandi-cli/issues/320","origin":"github"},"title":"Interface new implementation (API server) in dandi-cli top-level interfaces","message":"A decision was made in https://github.com/dandi/dandi-cli/pull/283 to aim to get `master` in a shape to support interaction with both current girder-based deployed dandiarchive **and** WiP https://github.com/dandi/dandi-api implementations within the same code base. I think it is doable.  #283 will provide \"internal\" interfaces for an upload/download cycle and then we would need to use/expose  them through top level interfaces.  For that, I think we should\n\n- to `known_instances` add a new entry `\"dandi-api\"` which would have no girder, we ui, redirector and only API. \n  - we would need also at least a `dandi-api-local-docker-tests` to point to the fixture'd instance\n  - we should not occlude other existing fixtures/instances such as `local-docker-tests` since they reflect the instances of currently deployed dandiarchive setup (albeit now without any API which was provided by publish. for a bit)\n  - most likely we should add `metadata-version` \"field\" to those records, where for old ones it would be 0 (unversioned ad-hoc), and then `1` for the new version of metadata (ideally it should [be the API server](https://github.com/dandi/dandi-api/issues/36) which tells which version of metadata schema it expects, but that is -- later).\n\n### upload\n\n- `--dandi-instance` option of `dandi upload` (in DANDI_DEVEL mode) would automagically list those added instance(s)\n  - `upload` code should be RFed (main logic is in [`process_path`](https://github.com/dandi/dandi-cli/blob/master/dandi/upload.py#L147) so it could support both upload to original girder-based client and new API-based one\n     - for new API-based one, metadata extraction should use new metadata (version 1) schema\n\n### download\n\nfor `download`, which does not rely on explicit specification of which instance to talk to, but parses from URL/identifier we need to come up with a \"schema\" on how to reference content from new API server, which would be easy on humans and flexible to support multiple instances/servers.  Specification/parsing of such urls should be added to `known_urls` (https://github.com/dandi/dandi-cli/blob/master/dandi/dandiarchive.py#L109).\n\nSo what about just taking what we had/(have) on a recent iteration with `publish` API and tune it to correspond to our API (`/dandisets/{version__dandiset__pk}/versions/{version__version}/assets/paths/`) call:\n\n```python\n       f\"{server_grp}#.*/(?P\u003casset_type\u003edandiset)s/{dandiset_id_grp}\"\n        \"/(?P\u003cversion\u003eversions/([.0-9]{5,}|draft))\"\n        \"(/assets/path(?location=(?P\u003clocation\u003e.*)?)?)?\"\n        \"$\": {\"server_type\": \"dandi-api\"}\n```\n\nNB initially I thought we might need to add some optional prefix `f\"(dandi-api::)?\" for early \"decision making\" but because of unique `/dandisets/` I think we do not need it\n\nso sample url for download would look like   \n\n- `https://api.dandiarchive.org/dandisets/000001`, `https://api.dandiarchive.org/dandisets/000001/versions/draft`, `https://api.dandiarchive.org/dandisets/000001/versions/draft/path/`  -- entire dataset, draft version\n- `https://api.dandiarchive.org/dandisets/000001/0.0.1` -- entire dataset, `0.0.1` version\n- `https://api.dandiarchive.org/dandisets/000001/draft/path/sub-XXX` -- sub-XXX folder (or a file if points to an asset) of draft version\n\ninstead of `api.dandiarchive.org`, urls could point to `localhost:port` in the test.\n\nLater, whenever web UI starts using API, we would need to adjust other \"schemas\". redirector will start redirecting to new web ui, possibly different urls.  But for now, IMHO it is sensible to just follow the API URLs.  Those will not be really \"visible\" to users, but would allow us to test new functionality/interaction with API server.","files":null}]}