{"version":2,"ops":[{"type":1,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1611176275,"metadata":{"github-id":"MDU6SXNzdWU3OTAzMTU3NDU=","github-url":"https://github.com/dandi/dandi-cli/issues/333","origin":"github"},"title":"model: need to avoid a \"pure\" Union or \"serialize\" it with type info","message":"this is to continue on our metadata meetup with @satra @jwodder @AlmightyYakob @waxlamp discussing the difficulties of establishing sensible while generic and scalable UI for (dandiset) metadata editing.\n\nOne of the problematic cases is the use of `Union` type/construct in the model, and then relying on pydantic to \"do the right choice\" of the underlying model while consuming data from serialized (yaml or json) data.\nHere is the `Union`s we have ATM (0.10.0-40-gcee1cbd):\n\n```shell\n$\u003e grep Union dandi/models.py | grep -v 'import'\n    unitCode: Union[str, AnyUrl] = Field(None, nskey=\"schema\")\n    value: Union[str, bool, int, float, List[Union[str, bool, int, float]]] = Field(\n    propertyID: Union[IdentifierType, AnyUrl, str] = Field(\nIdentifier = Union[AnyUrl, PropertyValue, str]\n    repository: Union[str, AnyUrl] = Field(\n    wasAssociatedWith: Optional[Union[Person, Organization, Software]] = Field(\n    contributor: Optional[List[Union[Person, Organization]]] = Field(\n    about: Optional[List[Union[Disorder, Anatomy, Identifier]]] = Field(\n    studyTarget: Optional[List[Union[str, AnyUrl]]] = Field(\n    wasGeneratedBy: Optional[Union[Activity, AnyUrl]] = Field(\n    contributor: List[Union[Person, Organization]] = Field(\n    doi: Optional[Union[str, AnyUrl]] = Field(\n    encodingFormat: Union[str, AnyUrl] = Field(\n```\nThe core assumption is that our types would have some attributes unique to them, so the choice of the type becomes unambiguous. It is not the case ATM (if ever could be achieved), and here are some thoughts/observations:\n\n### Order of types should not matter but it does, preventing round trip to .json and back\n\nATM pydantic would choose the first type (in the list within Union) which 'satisfies' the data. Unfortunately IMHO this is a mis-*feature* and ideally we should not rely on it.  It makes it virtually impossible to define/use two types which have only a semantic difference by being different types and otherwise having the same attributes.  E.g., \n\n- we cannot place any two TypeModel subclasses which have no non-optional attributes into a Union (e.g. Anatomy and Disorder for `about` above; Disorder does have an attribute `dxdate` but it is optional), since then former would always take \"precedence\" when we just read in serialized data without any type annotation. So ATM we cannot do R/T on those into/from serialized form which has no type annotations. Yes, we could \"improve\" the schema models by making them more 'specialized' (magic word to mention here: \"Ontologies\") but IMHO it would be \"artificial\"/duplicate/fragile (depending on the case ;)), since semantically we already know that they are different types, since we defined them separately. \n- we have to \"order\" types from more specialized to a more generic one. E.g. in above we have a number of `Union[str, AnyUrl]`. We would need to swap the order because otherwise no R/T is possible since `AnyUrl` serializes just into a URL\n\u003cdetails\u003e\n\u003csummary\u003equick demo\u003c/summary\u003e \n\n```python\ndef test_yarik_assumptions():\n    import json\n    from dandi.models import DandiBaseModel, Union, Field, AnyUrl\n\n    class WithUrl(DandiBaseModel):\n        a: Union[str, AnyUrl] = Field(None, nskey=\"schema\")\n\n    url = AnyUrl(\"http://purl.obolibrary.org/obo/PATO_0000384\",\n                        scheme=\"http\",\n                        host=\"purl.obolibrary.org\",\n                        tld=\"org\",\n                        host_type=\"domain\",\n                        path=\"/obo/PATO_0000384\")\n    v1 = WithUrl(a=url)\n    print(f'str: {v1}')\n    print(f'repr: {v1!r}')\n    v1_json = v1.json(exclude_unset=True, exclude_none=True)\n    print(f'json: {v1_json}')\n    v1_rt = WithUrl(**json.loads(v1_json))\n    print(f'R/T repr: {v1_rt!r}')\n```\n\nresults in\n```\nstr: a=AnyUrl('http://purl.obolibrary.org/obo/PATO_0000384', scheme='http', host='purl.obolibrary.org', tld='org', host_type='domain', path='/obo/PATO_0000384')\nrepr: WithUrl(a=AnyUrl('http://purl.obolibrary.org/obo/PATO_0000384', scheme='http', host='purl.obolibrary.org', tld='org', host_type='domain', path='/obo/PATO_0000384'))\njson: {\"a\": \"http://purl.obolibrary.org/obo/PATO_0000384\"}\nR/T repr: WithUrl(a='http://purl.obolibrary.org/obo/PATO_0000384')\n```\n\u003c/details\u003e\nwell we could (and probably should) swap and place `AnyUrl` first.  But it would \"introduce\" a *super power* that any url-like string would become a AnyUrl upon R/T.  Some might consider it a feature, I would not: I do not think we should \"mutate\" types upon a validator just stating that something doesn't look like something else.\n\n- we would need to add testing of our schema to ensure so it is unambigous and order does not matter (burden/fragility again in case of model extensions) or otherwise we would cause data types \"mutation\" upon migration between schemas\n- it makes it ambiguous to the user seeing serialized data on what type it is if multiple can \"match\" (think Organization vs Person if only `name`, `url`, `email` are provided) (see another example below).\n- ideally then we need to maintain \"pydantic\" code (not just json schema; and ideally with exact versions of pydantic used ;) ) for each version to be able to migrate serialized metadata while accounting for possibly different order effects across different versions of the models\n\n### So my question is ...\n\nis there is some existing already type construct we could use instead of `Union` or in addition (alike a \"decorator\" for each value then which would disclose the \"type\") so that serialized data (given the schema) could be unambigously deserialized? \n\nE.g. taking for example the top of https://github.com/dandi/dandi-api-datasets/blob/master/000004/dandiset.yaml (in current schema):\n\n```yaml\nabout:\n- identifier: MTL\n  name: Medial Temporal Lobe\n```\nwhich corresponds to\n```\nabout: Optional[List[Union[Disorder, Anatomy, Identifier]]] = Field(\n```\nwhere it takes my unquestionably high expertise in the matter to say that it is an `Anatomy`  and not e.g. `Disorder`... (Exercising on the case of the `List[Union]` not just pure `Union` but I think it should generalize). I could see a following serialization which would disambiguate\n\n```yaml\nabout:\n- anatomy:\n  - identifier: MTL\n    name: Medial Temporal Lobe\n```\n\n```yaml\nabout:\n- identifier: MTL\n  name: Medial Temporal Lobe\n  _schemaType: anatomy\n```\n\nBoth would make serialization only a bit heavier, but clear(er) to humans and computers (UI) and thus allow for R/T. The latter one is IMHO more \"generic\" if for every value participating in a `Union`ed type we export the `_schemaType`.  That would then apply only to values which are part of the union, and make it easily \"upgradeable\": if we make some attribute from a single to Union type, it will just add that \"protected\" attribute to an existing record without changing actual \"layout\". \n\n**BUT** it would make it quite ugly in case of that simple case of `AnyUrl, str`.  My answer would be: *that is a reasonable compromise to achieve unambiguous R/T at a minor cost of visual/human readability*.  But may be we could do better, and just establish a \"programmable\" rule that in the case of the first Type chosen in the Union, we omit explicit `_schemaType`? then it could be coded in any schema handling.\n\nYet another (wild idea) alternative is to forget about JSON and use its superset YAML for serialization, and then provide type annotations in the comments \n```yaml\nabout:\n- identifier: MTL  # type: anatomy\n  name: Medial Temporal Lobe\n```\neven though it would likely inflict more developer pains (in particular in JS world; and I have no clue if it would be feasible to achieve with pydantic ATM) while making it more user-friendly.  That would also keep opportunities for later using additional features of YAML: anchors (`\u0026`) and references (`*`) in case of those circular entities (not the topic of this \"post\") we touched upon.","files":null}]}