{"version":2,"ops":[{"type":1,"author":{"id":"34bb3b7763ea6d04cae1c21ede40209df34305b5"},"timestamp":1684338076,"metadata":{"github-id":"I_kwDODBZtRc5mLGu3","github-url":"https://github.com/dandi/dandi-cli/issues/1289","origin":"github"},"title":"make .exists( check of pathlib into the one to support broken symlinks","message":"came up during review of https://github.com/dandi/dandi-cli/pull/1286/files#diff-cdc58989d7a5c424994a24e3e9a85a7a03a4c7c2594e0feb139d7ebea7d387a6R55 \n\n\u003cdetails\u003e\n\u003csummary\u003eit seems we are making a good number of checks using `.exists`\u003c/summary\u003e \n\n```shell\n‚ùØ git grep -p '\\.exists(' | grep -v -e test -e versionee\ndandi/dandiset.py=    def __init__(self, path: Union[str, Path], allow_empty: bool = False) -\u003e None:\ndandi/dandiset.py:        if not allow_empty and not (self.path_obj / dandiset_metadata_file).exists():\ndandi/dandiset.py=    def _load_metadata(self) -\u003e None:\ndandi/dandiset.py:        if self._metadata_file_obj.exists():\ndandi/dandiset.py=    def update_metadata(self, meta: dict) -\u003e None:\ndandi/dandiset.py:        if self._metadata_file_obj.exists():\ndandi/download.py=    def __enter__(self) -\u003e DownloadDirectory:\ndandi/download.py:            if not chkpath.exists():\ndandi/files/__init__.py=def find_dandi_files(\ndandi/files/__init__.py:                if (p / BIDS_DATASET_DESCRIPTION).exists():\ndandi/files/__init__.py:                    if (p / BIDS_DATASET_DESCRIPTION).exists() and not any(\ndandi/files/bids.py=    def _validate(self) -\u003e None:\ndandi/files/bids.py:                        readme_candidate.exists()\ndandi/files/zarr.py=    def exists(self) -\u003e bool:\ndandi/files/zarr.py:        return self.filepath.exists()\ndandi/keyring.py=def keyring_op(\ndandi/keyring.py:        if op.exists(kb.file_path):\ndandi/keyring.py:            if keyring_cfg.exists():\ndandi/move.py=    def get_path(self, path: str, is_src: bool = True) -\u003e File | Folder:\ndandi/move.py:        if not p.exists():\ndandi/organize.py=def organize_external_files(\ndandi/organize.py:                if not op.exists(name_old_str):\ndandi/organize.py=def populate_dataset_yml(filepath, metadata):\ndandi/organize.py:    if not op.exists(filepath):\ndandi/organize.py=        def act(func, *args, **kwargs):\ndandi/organize.py:        if op.exists(dandiset_path):\ndandi/organize.py=        def _get_metadata(path):\ndandi/organize.py:    if not op.exists(dandiset_path):\ndandi/organize.py:        if op.exists(dandi_fullpath):\ndandi/organize.py:            if not op.exists(dandi_dirpath):\ndandi/organize.py:            if op.exists(d):\ndandi/upload.py=        def upload_agg(*ignored: Any) -\u003e str:\ndandi/upload.py:                    and not Path(dandiset.path, asset.path).exists()\ndandi/utils.py=def find_parent_directory_containing(\ndandi/utils.py:        if (path / filename).exists():\ntools/update-assets-on-server=def process_dandiset(dandiset, update, api_key):\ntools/update-assets-on-server:        if not os.path.exists(localpath):\n\n```\n\u003c/details\u003e\n\nas those files could be under `git-annex` control and exist as symlink but not really available with content, we should code those paths with that awareness. E.g. in many cases we should not make logic based on `.exists` but rather on `.lexists` to e.g. try to load from a file or not.  So it is desired to go through these and either replace with `.lexists` in case of using `os.path` or some create/use helper for checks of [pathlib.Paths (since there is no .lexists there).","files":null}]}